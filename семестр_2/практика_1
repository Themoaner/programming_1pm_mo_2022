/*Реализуйте класс, который будет выполнять шифрование и дешифрование сообщения на английском языке.
Длина сообщения не более 30 слов. Словом называется последовательность символов до первого пробела.
Знак препинания после символов тоже входит в слово.
Ключом является последовательность Фибоначчи.*/

#include <iostream>
#include <string>
#include <vector>

class Encryption
{
private:
	std::string m_line;
	//std::vector<std::string> m_message;
	std::string m_mas[30];
	std::vector<std::string> m_encode;
	std::vector<std::string> m_decode;
	//std::vector<std::string> m_Words;
	std::vector<int> m_FKey = { 1, 2 };
	std::vector<int> m_currentKey;
	int amountOfWords = 1;

	void WordCounter(std::string line)
	{
		for (int i = 0; i < line.length(); i++)
		{
			if (line[i] ==' ')
				amountOfWords += 1;
		}
	}

	void Fibonacci()
	{
		for (int i = 2; i < amountOfWords; i++)
		{
			m_FKey.push_back(m_FKey[i - 1] + m_FKey[i - 2]);
		}
	}

public:
	Encryption(/*std::vector<std::string> message, */std::vector<int> currentKey, std::string line)
	{
		//m_message = message;
		m_currentKey = currentKey;
		m_line = line;
		WordCounter(line);
		Fibonacci();
	}

	void Words()
	{
		int i = 0;
		for (int j = 0; j < m_line.length(); j++)
		{
			if (m_line[j] != ' ')
			{
				m_mas[i] += m_line[j];
			}
			else if (m_line[j] == ' ')
			{
				i++;
			}
		}
		/*for (int i = 0; i < amountOfWords; i++)
		{
			m_Words.push_back(m_mas[i]);
		}*/
		/*for (int i = 0; i < m_Words.size(); i++)
		{
			std::cout << m_Words[i] << " ";
		}
		std::cout << std::endl;
		for (int i = 0; i < amountOfWords; i++)
		{
			std::cout << m_mas[i] << " ";
		}
		std::cout << std::endl;*/
	}

	void InputKey()
	{
		std::cout << "Enter the key" << std::endl << "(-1) is a breakpoint" << std::endl;
		int a;
		while (std::cin >> a) 
		{
			if (a == -1) break;
			m_currentKey.push_back(a);
			
		}
		
	}

	bool Equal(std::vector<int> V1, std::vector<int> V2)
	{
		int coincidence = 0;
		for (int i = 0; i < amountOfWords; i++)
		{
			for (int j = 0; j < amountOfWords; j++)
			{
				if (V1[i] == V2[j])
				{
					coincidence += 1;
				}
			}
		}

		if (coincidence == amountOfWords)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	void check_currentKey()
	{
		//std::cout << m_currentKey.size() << " " << m_FKey.size() << " " << amountOfWords << std::endl;
		if (Equal(m_currentKey, m_FKey) == false)
		{
			std::cout << "Wrong Key" << std::endl;
		}
	}


	void Encode() 
	{
		if (Equal(m_currentKey, m_FKey) == true)
		{
			//std::string buffer;
			for (int i = 0; i < amountOfWords; i++)
			{
				for (int j = 0; j < amountOfWords; j++)
				{
					if (m_currentKey[i] == m_FKey[j])
					{
						m_encode.push_back(m_mas[j]);
						//std::swap(m_mas[i], m_mas[j]);
						/*buffer = m_Words[i];
						m_Words[i] = m_Words[j];
						m_Words[j] = buffer;*/
					}
				}
			}
		}
		//for (int i = 0; i < amountOfWords; i++)
		//{
		//	std::cout << m_mas[i] << " ";
		//	//std::cout << m_Words[i] << " ";
		//}
		//std::cout << std::endl;
		//for (int i = 0; i < amountOfWords; i++)
		//{
		//	std::cout << m_currentKey[i] << " ";
		//}
	}

	//void Decode()
	//{
	//	if (Equal(m_currentKey, m_FKey) == true)
	//	{
	//		//std::string buffer;
	//		for (int i = amountOfWords; i > 0; i--)
	//		{
	//			for (int j = amountOfWords; j > 0; j--)
	//			{
	//				if (m_currentKey[i] > m_currentKey[j])
	//				{
	//					std::swap(m_mas[i], m_mas[j]);
	//					/*buffer = m_Words[i];
	//					m_Words[i] = m_Words[j];
	//					m_Words[j] = buffer;*/
	//				}
	//			}
	//		}
	//	}
	//}

	void Output1()
	{
		for (int i = 0; i < amountOfWords; i++)
		{
			std::cout << m_encode[i] << " ";
			//std::cout << m_Words[i] << " ";
		}
		std::cout << std::endl;
		for (int i = 0; i < amountOfWords; i++)
		{
			std::cout << m_currentKey[i] << " ";
		}
	}

	void Output2()
	{
		for (int i = 0; i < amountOfWords; i++)
		{
			std::cout << m_decode[i] << " ";
			//std::cout << m_Words[i] << " ";
		}
		std::cout << std::endl;
		for (int i = 0; i < amountOfWords; i++)
		{
			std::cout << m_currentKey[i] << " ";
		}
	}
};

int main()
{
	//std::vector<std::string> message;
	std::string line;
	std::vector<int> currentKey;
	std::cout << "Enter the message" << std::endl;
	std::getline(std::cin, line);
	Encryption SK(/*message, */currentKey, line);
	SK.Words();
	SK.InputKey();
	SK.check_currentKey();
	SK.Encode();
	//SK.Decode();
	SK.Output1();
	//SK.Output2();

	system("pause");
	return 0;
}
