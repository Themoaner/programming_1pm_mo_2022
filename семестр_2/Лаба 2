//Реализуйте класс String для работы со строками. У вас должны быть реализованы :
//1.+	Базовый конструктор
//2.+	Конструктор копирования(правило 3 - х)
//3.+	Оператор присваивания копированием(правило 3 - х)
//4.+	Деструктор(правило 3 - х)
//5.	Операторы + и +=
//6.+	Оператор[] – чтение и изменение элемента
//7.+	Операторы <, >, ==
//8.	Операторы ввода и вывода в поток
//9.+	Метод find – поиск первого вхождения символа в строку слева
//10.+	Метод length – длина строки
//11.	Метод c_str – получить массив char
//12.+	Метод at для получения доступа(чтение и изменение) к элементу строки с проверкой на выход за пределы строки

#include <iostream>
#include <cstring>
struct String
{
private:
	size_t m_size;
	char* m_str = nullptr;

public:
	String() = default;
	String(int c, size_t size) = delete; // Запрет неявного преобразования типов из int в char

	//1.1.) Базовый Конструктор
	String(char c, size_t size) : m_size(size), m_str(new char[size + 1])
	{
		std::fill(m_str, m_str + m_size, c);
		m_str[m_size] = 0;
		std::cout << "Basic constr." << std::endl;
	}

	//1.2.) Конструктор от строки, список инициализации членов класса (Member initializer)
	String(char* str) : m_size(strlen(str)), m_str(new char[m_size])
	{
		std::copy(str, str + m_size, m_str);
		m_str[m_size] = 0;
		std::cout << "Constr. from str." << std::endl;
	}

	//2.) Конструктор копирования + делигирующий конструктор
	String(const String& other) : String(other.m_str)
	{
		m_size = other.m_size;
		//Выделили память
		m_str = new char[m_size];
		//Копируем строку из other
		std::copy(other.m_str, other.m_str + other.m_size, m_str);
		std::cout << "Copy" << std::endl;
	}


	//3.) Оператор присваивания копированием
	String& operator=(String& temp)
	{
		// Идиома copy-and-swap
		std::swap(m_size, temp.m_size);
		std::swap(m_str, temp.m_str);
		/*delete[] m_str;
		m_size = other.m_size;
		m_str = new char[m_size];
		std::copy(other.m_str, other.m_str + other.m_size, m_str);*/
		std::cout << "Copy-and-swap" << std::endl;
		return *this;
	}


	//4.) Деструктор
	~String()
	{
		if (m_str != nullptr)
		{
			delete[] m_str;
		}
		std::cout << "Destructor" << std::endl;
	}


////5.	Операторы + и +=
//String& operator+(const String& other)
//{
//	String result('a', m_size + other.m_size - 1);
//	for (int i = 0; i < (m_size - 1); i++)
//	{
//		for (int j = m_size - 1; j < (m_size + other.m_size - 2); j++)
//		{
//			result[i] = m_str[i];
//			result[j] = other.m_str[j];
//		}
//	}
//	std::cout << "Operator +" << std::endl;
//	return result;
//}


	//6.) Оператор[]
	char& operator[](int i)
	{
		//std::cout << "Operator[]" << std::endl;
		return m_str[i];
	}

	//7.	Операторы <, >, ==
	bool operator==(const String& other) const
	{
	    std::cout << "Operator ==" << std::endl;
	    if ((*this).m_size != other.m_size)
	    {
	        return false;
	    }
	    for (int i = 0; i < (*this).m_size - 1; i++)
	    {
	        if ((*this).m_str[i] != other.m_str[i])
	        {
	            return false;
	        }
	    }
	    return true;
	}

    bool operator<(const String& other) const
	{
	    int max = std::max((*this).m_size, other.m_size);
	    std::cout << "Operator <" << std::endl;
	    for (int i = 0; i < max; i++)
	    {
	        if ((*this).m_str[i] > other.m_str[i])
	        {
	            return false;
	        }
	    }
	    if (*this == other)
	    {
	        return false;
	    }
	    if ((*this).m_size > other.m_size)
	    {
	        return false;
	    }
	    else {return true;}
	}
	
	bool operator>(const String& other) const
	{
	    std::cout << "Operator >" << std::endl;
	    if (*this == other)
	    {
	        return false;
	    }
	    if (*this < other)
	    {
	        return false;
	    }
	    else {return true;}
	}

	//8.	Операторы ввода и вывода в поток



	//9.) Метод find – поиск первого вхождения символа в строку слева
	int Find(const char c)
	{
		for (int i = 0; i < (m_size - 1); i++)
		{
			if (m_str[i] == c)
			{
				std::cout << "Find" << std::endl;
				return i;
			}
		}
		return -1;
	}

	//10.) Length
	int length()
	{
		std::cout << "Length" << std::endl;
		return (m_size - 1);
	}

	//11.	Метод c_str – получить массив char



	//12.	Метод at для получения доступа(чтение и изменение) к элементу строки с проверкой на выход за пределы строки
	char& at(int index)
	{
		if (0 <= index <= (m_size - 1))
		{
			std::cout << "at" << std::endl;
			return m_str[index];
		}
		else
		{
			std::cout << "incorect index";
		}
	}

	void Print() const
	{
		for (int i = 0; i < m_size; i++)
		{
			std::cout << m_str[i];
		}
		std::cout << std::endl;
	}
};

int main()
{
	char s[5] = { 'b','b','d','b','b' };
	char s1[1] = {'a'};
	String S1('a', 5);
	String S2(s);
	String S3(S2);
	String S4(s1);
	S4 = S1;
	//String Sum = S1 + S2;


	S1.Print();
	S2.Print();
	S3.Print();
	S4.Print();
	//Sum.Print();

    std::cout << (S2 == S3) << std::endl;
    std::cout << (S1 < S2) << std::endl;
    std::cout << (S1 > S2) << std::endl;
//	std::cout << S4[2] << std::endl;
//	std::cout << S2.Find('d') << std::endl;
//	std::cout << S3.length() << std::endl;

	return 0;
}
