//Реализуйте класс String для работы со строками. У вас должны быть реализованы :
//1.+	Базовый конструктор
//2.+	Конструктор копирования(правило 3 - х)
//3.+	Оператор присваивания копированием(правило 3 - х)
//4.+	Деструктор(правило 3 - х)
//5.+	Операторы + и +=
//6.+	Оператор[] – чтение и изменение элемента
//7.+	Операторы <, >, ==
//8.+	Операторы ввода и вывода в поток
//9.+	Метод find – поиск первого вхождения символа в строку слева
//10.+	Метод length – длина строки
//11.+	Метод c_str – получить массив char
//12.+	Метод at для получения доступа(чтение и изменение) к элементу строки с проверкой на выход за пределы строки
#pragma warning(disable: 4996)
#include <iostream>
#include <cstring>

struct String
{
private:
	size_t m_size;
	char* m_str = nullptr;
	friend std::istream& operator >> (std::istream& in, String& s);
	friend std::ostream& operator<<(std::ostream& out, const String& s);



public:
	String() = default;
	String(int c, size_t size) = delete; // Запрет неявного преобразования типов из int в char

	//1.1.) Базовый Конструктор
	String(char c, size_t size) : m_size(size), m_str(new char[size + 1])
	{
		std::fill(m_str, m_str + m_size, c);
		m_str[m_size] = 0;
		std::cout << "Basic constr." << std::endl;
	}

	//1.2.) Конструктор от строки, список инициализации членов класса (Member initializer)
	String(char* str) : m_size(strlen(str)), m_str(new char[m_size])
	{
		std::copy(str, str + m_size, m_str);
		m_str[m_size] = 0;
		std::cout << "Constr. from str." << std::endl;
	}

	//2.) Конструктор копирования + делигирующий конструктор
	String(const String& other) : String(other.m_str)
	{
		m_size = other.m_size;
		//Выделили память
		m_str = new char[m_size];
		//Копируем строку из other
		std::copy(other.m_str, other.m_str + other.m_size, m_str);
		m_str[m_size] = '\0';
		std::cout << "Copy" << std::endl;
	}


	//3.) Оператор присваивания копированием
	String& operator=(String& temp)
	{
		// Идиома copy-and-swap
		std::swap(m_size, temp.m_size);
		std::swap(m_str, temp.m_str);
		/*delete[] m_str;
		m_size = other.m_size;
		m_str = new char[m_size];
		std::copy(other.m_str, other.m_str + other.m_size, m_str);*/
		std::cout << "Copy-and-swap" << std::endl;
		return *this;
	}


	//4.) Деструктор
	~String()
	{
		if (m_str != nullptr)
		{
			delete[] m_str;
		}
		std::cout << "Destructor" << std::endl;
	}


	//5.	Операторы + и +=
	String operator+(String& other)
	{
		String result('a', m_size + other.m_size);
		for (int i = 0; i < m_size; i++)
		{
			result[i] = m_str[i];
		}
		for (int i = m_size; i < (m_size + other.m_size); i++)
		{
			result[i] = other[i - m_size];
		}
		std::cout << "Operator +" << std::endl;
		return result;
	}

	String& operator+=(String& other)
	{
		m_size = m_size + other.m_size;
		for (int i = m_size - other.m_size; i < m_size; i++)
		{
			m_str[i] = other[i - other.m_size];
		}
		m_str[m_size] = '\0';
		std::cout << "Operator +=" << std::endl;
		return *this;
	}

	//6.) Оператор[]
	char& operator[](int i)
	{
		//std::cout << "Operator[]" << std::endl;
		return m_str[i];
	}

	//7.	Операторы <, >, ==
	bool operator==(const String& other) const
	{
		std::cout << "Operator ==" << std::endl;
		if ((*this).m_size != other.m_size)
		{
			return false;
		}
		for (int i = 0; i < (*this).m_size - 1; i++)
		{
			if ((*this).m_str[i] != other.m_str[i])
			{
				return false;
			}
		}
		return true;
	}

	bool operator<(const String& other) const
	{
		return strcmp(this->m_str, other.m_str) < 0;
		/*int max = std::max((*this).m_size, other.m_size);
		std::cout << "Operator <" << std::endl;
		for (int i = 0; i < max; i++)
		{
		if ((*this).m_str[i] > other.m_str[i])
		{
		return false;
		}
		}
		if (*this == other)
		{
		return false;
		}
		if ((*this).m_size > other.m_size)
		{
		return false;
		}
		else { return true; }*/
	}

	bool operator>(const String& other) const
	{
		std::cout << "Operator >" << std::endl;
		if (*this == other)
		{
			return false;
		}
		if (*this < other)
		{
			return false;
		}
		else { return true; }
	}




	//9.) Метод find – поиск первого вхождения символа в строку слева
	int Find(const char c)
	{
		for (int i = 0; i < (m_size - 1); i++)
		{
			if (m_str[i] == c)
			{
				std::cout << "Find" << std::endl;
				return i;
			}
		}
		return -1;
	}

	//10.) Length
	int length()
	{
		std::cout << "Length" << std::endl;
		return (m_size);
	}

	//11.	Метод c_str – получить массив char
	const char* c_str()
	{
		std::cout << "c_str" << std::endl;
		return m_str;
	}


	//12.	Метод at для получения доступа(чтение и изменение) к элементу строки с проверкой на выход за пределы строки
	char& at(int index)
	{
		if (0 <= index <= (m_size - 1))
		{
			std::cout << "at" << std::endl;
			return m_str[index];
		}
		else
		{
			std::cout << "incorect index";
		}
	}

	void Print() const
	{
		for (int i = 0; i < m_size; i++)
		{
			std::cout << m_str[i];
		}
		std::cout << std::endl;
	}
};

//8.	Операторы ввода и вывода в поток
std::ostream& operator<<(std::ostream& out, const String& s)
{
	out << s.m_str;
	return out;
}

std::istream& operator >> (std::istream& in, String& s)
{
	char* mas = new char[1000];
	int i = 0;
	int size = 0;
	in >> mas;
	while (true)
	{
		if (mas[i] == '\0' || mas[i] == '\n')
		{
			size = i;
			break;
		}
		i++;

	}
	s.m_size = size+1;
	s.m_str = new char[s.m_size+1];
	std::copy(mas, mas + size+1, s.m_str);
	return in;

}

int main()
{
	//char s[5] = { 'b','b','d','b','b' };
	//char s1[1] = { 'a' };
	String S1('c', 4);
	String S2("bbdbb");
	String S3(S2);
	String S4 = S1;
	String S5('g', 4);
	String Sum = S1 + S2;
	S1 += S5;

	
	//std::cout << Sum.length() << std::endl;
	std::cout << S1 << std::endl;
	std::cout << S2 << std::endl;
	std::cout << S3 << std::endl;
	std::cout << S4 << std::endl;
	std::cout << S5 << std::endl;

	//std::cin >> S1;
	//std::cout << S1 << std::endl;
	
	//S1.Print();
	//S2.Print();
	//S3.Print();
	//S4.Print();
	//Sum.Print();

	std::cout << S3.length() << std::endl;
	std::cout << S1.c_str() << std::endl;
	std::cout << (S2 == S3) << std::endl;
	std::cout << (S1 < S2) << std::endl;
	std::cout << (S1 > S2) << std::endl;
	std::cout << S4[2] << std::endl;
	std::cout << S2.Find('d') << std::endl;
	std::cout << S3.length() << std::endl;

	system("pause");
	return 0;
}
